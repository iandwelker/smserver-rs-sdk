use std::{
	thread::sleep,
	time::Duration,
	sync::{
		mpsc,
		Arc,
		RwLock
	},
	collections::HashMap
};
use tokio_tungstenite::{
	WebSocketStream,
	tungstenite::{
		Error,
		Message,
		protocol
	}
};
use tokio_native_tls::TlsStream;
use tokio::net::TcpStream;
use futures_util::{
	StreamExt,
	SinkExt,
	stream::{
		SplitStream,
		SplitSink
	}
};
use serde_json::{
	json,
	Value,
};
use crate::{
	commands::*,
	socket::SocketResponse,
};

pub struct SocketHandler {
	pub sender: SplitSink<WebSocketStream<TlsStream<TcpStream>>, Message>,
}

impl SocketHandler {
	pub async fn new(
		url: url::Url,
		channel_sender: mpsc::SyncSender<SocketResponse>,
		sock_msgs: Arc<RwLock<HashMap<String, mpsc::SyncSender<SocketResponse>>>>
	) -> Result<SocketHandler, Error> {
		let sock_res = SocketHandler::get_self_signed_socket(url).await?;

		let (sender, receiver) = sock_res.split();

		SocketHandler::spawn_receiver(receiver, channel_sender, sock_msgs);

		Ok(SocketHandler { sender })
	}

	pub fn spawn_receiver(
		receiver: SplitStream<WebSocketStream<TlsStream<TcpStream>>>,
		channel_sender: mpsc::SyncSender<SocketResponse>,
		sock_msgs: Arc<RwLock<HashMap<String, mpsc::SyncSender<SocketResponse>>>>
	) {
		tokio::spawn(async move {
			let mut rec = receiver;

			while let Some(Ok(msg)) = rec.next().await {
				let txt = match msg {
					Message::Text(txt) => Some(txt),
					_ => None,
				};

				let resp: Option<SocketResponse> = if let Some(text) = txt {
					match serde_json::from_str(&text) {
						Ok(resp) => Some(resp),
						Err(_) => None
					}
				} else {
					None
				};

				if let Some(res) = resp {
					if let Ok(mut msgs) = sock_msgs.write() {
						let id = res.id.to_owned();

						if let Some(id_send) = msgs.get(&id) {
							let last = res.last;

							match id_send.send(res) {
								_ => ()
							}

							if last {
								msgs.remove(&id);
							}
						} else {
							match channel_sender.send(res) {
								_ => ()
							}
						}
					}
				}
			}
		});
	}

	pub async fn get_self_signed_socket(
		url: url::Url
	) -> Result<WebSocketStream<TlsStream<TcpStream>>, Error> {

		// need this custom connector so that it connects with
		// SMServer's self-signed cert
		let connector = native_tls::TlsConnector::builder()
			.danger_accept_invalid_certs(true)
			.danger_accept_invalid_hostnames(true)
			.use_sni(false)
			.build()
			.expect("Couldn't build tls connector");

		let tokio_connector = tokio_native_tls::TlsConnector::from(connector);

		let host = url.host().expect("Please supply as socket host")
			.to_string();

		let addr = format!("{}:{}", host, url.port().unwrap_or(8741));

		// ngl I don't understand this part perfectly
		// but it was online and it works
		let mut stream_try = TcpStream::connect(&addr).await;

		let mut tls_stream: Option<tokio_native_tls::TlsStream<TcpStream>> = None;

		// gotta do a loop so that it keeps trying to
		// re-connect if it fails initially
		while tls_stream.is_none() {
			match stream_try {
				Ok(stream) => {
					tls_stream = Some(tokio_connector.connect(&host, stream).await
						.expect("Couldn't connect to valid TLS Stream"));
					break;
				},
				Err(_) => {
					sleep(Duration::from_secs(2));
					stream_try = TcpStream::connect(&addr).await;
				}
			}
		}

		let config = Some(protocol::WebSocketConfig {
			max_send_queue: None,
			max_message_size: None,
			max_frame_size: None,
			accept_unmasked_frames: false
		});

		Ok(tokio_tungstenite::client_async_with_config(
			url,
			tls_stream.expect("Valid TLsStream became invalid"),
			config,
		).await?.0)
	}

	// all the functions to send commands are generated by the
	// custom `Command` derive macro, which is run on the enum `APICommand`

	pub async fn send_command(
		&mut self, cmd: APICommand, params: Value
	) -> Result<String, Error> {
		// this returns the `id` that it generates, so that it can
		// later be used to grab the response when it comes back in
		let id = uuid::Uuid::new_v4().to_string();

		let payload = json!({
			"id": id,
			"command": cmd.command_string(),
			"params": params
		});

		self.sender.send(Message::Text(payload.to_string())).await?;

		Ok(id)
	}
}
