use std::{
	thread::sleep,
	time::Duration,
	sync::mpsc,
};
use tokio_tungstenite::{
	WebSocketStream,
	tungstenite::{
		Error,
		Message,
		protocol
	}
};
use tokio_native_tls::TlsStream;
use tokio::net::TcpStream;
use futures_util::{
	StreamExt,
	SinkExt,
	stream::{
		SplitStream,
		SplitSink
	}
};
use serde_json::{
	json,
	Value,
};
use crate::{
	commands::*,
	socket::SocketResponse,
};

pub struct SocketHandler {
	pub sender: SplitSink<WebSocketStream<TlsStream<TcpStream>>, Message>,
}

impl SocketHandler {
	pub async fn new(
		port: u32,
		address: &str,
		secure: bool,
		subdirectory: Option<&str>,
		channel_sender: mpsc::Sender<SocketResponse>
	) -> Result<SocketHandler, Error> {
		let sock_res = SocketHandler::get_self_signed_socket(
			port, address, secure, subdirectory
		).await?;

		let (sender, receiver) = sock_res.split();

		SocketHandler::spawn_receiver(receiver, channel_sender);

		Ok(SocketHandler { sender })
	}

	pub fn spawn_receiver(
		receiver: SplitStream<WebSocketStream<TlsStream<TcpStream>>>,
		channel_sender: mpsc::Sender<SocketResponse>
	) {
		tokio::spawn(async move {
			let mut rec = receiver;

			while let Some(Ok(msg)) = rec.next().await {
				let txt = match msg {
					tokio_tungstenite::tungstenite::Message::Text(txt) => Some(txt),
					_ => None,
				};

				if let Some(text) = txt {
					if let Ok(resp) = serde_json::from_str(&text) {
						match channel_sender.send(resp) {
							Err(err) =>
								eprintln!("Failed to send mpsc message: {:?}", err),
							_ => ()
						}
					}
				}
			}
		});
	}

	pub async fn get_self_signed_socket(
		port: u32, host: &str, secure: bool, subdirectory: Option<&str>
	) -> Result<WebSocketStream<TlsStream<TcpStream>>, Error> {

		// need this custom connector so that it connects with
		// SMServer's self-signed cert
		let connector = native_tls::TlsConnector::builder()
			.danger_accept_invalid_certs(true)
			.danger_accept_invalid_hostnames(true)
			.use_sni(false)
			.build()
			.expect("Couldn't build tls connector");

		let tokio_connector = tokio_native_tls::TlsConnector::from(connector);

		let addr = format!("{}:{}", host, port);

		// ngl I don't understand this part perfectly
		// but it was online and it works
		let mut stream_try = TcpStream::connect(&addr).await;

		let mut tls_stream: Option<tokio_native_tls::TlsStream<TcpStream>> = None;

		// gotta do a loop so that it keeps trying to
		// re-connect if it fails initially
		while tls_stream.is_none() {
			match stream_try {
				Ok(stream) => {
					tls_stream = Some(tokio_connector.connect(&host, stream).await
						.expect("Couldn't connect to valid TLS Stream"));
					break;
				},
				Err(_) => {
					sleep(Duration::from_secs(2));
					stream_try = TcpStream::connect(&addr).await;
				}
			}
		}

		let config = Some(protocol::WebSocketConfig {
			max_send_queue: None,
			max_message_size: None,
			max_frame_size: None,
			accept_unmasked_frames: false
		});

		let subdir = subdirectory.unwrap_or("");

		let url = format!("ws{}://{}/{}",
			if secure { "s" } else { "" }, addr, subdir);
		let parsed_url = url::Url::parse(&url)
			.expect(&format!("Failed to parse websocket URL: '{}'", url));

		Ok(tokio_tungstenite::client_async_with_config(
			parsed_url,
			tls_stream.expect("Valid TLsStream became invalid"),
			config,
		).await?.0)
	}

	// all the functions to send commands are generated by the
	// custom `Command` derive macro, which is run on the enum `APICommand`

	pub async fn send_command(
		&mut self, cmd: APICommand, params: Value
	) -> Result<String, Error> {
		let id = uuid::Uuid::new_v4().to_string();

		let payload = json!({
			"id": id,
			"command": cmd.command_string(),
			"params": params
		});

		self.sender.send(Message::Text(payload.to_string())).await?;

		Ok(id)
	}
}
