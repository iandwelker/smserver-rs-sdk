use std::sync::{
	mpsc,
	Arc,
};
use dashmap::DashMap;
use tokio_tungstenite::{
	WebSocketStream,
	tungstenite::{
		Error,
		Message,
	}
};
use tokio_native_tls::TlsStream;
use tokio::net::TcpStream;
use futures_util::{
	StreamExt,
	SinkExt,
	stream::{
		SplitStream,
		SplitSink
	}
};
use serde_json::{
	json,
	Value,
};
use crate::{
	commands::*,
	socket::SocketResponse,
};

pub struct SocketHandler {
	pub sender: SplitSink<WebSocketStream<TlsStream<TcpStream>>, Message>,
}

impl SocketHandler {
	pub async fn new(
		url: url::Url,
		channel_sender: mpsc::SyncSender<SocketResponse>,
		sock_msgs: Arc<DashMap<String, mpsc::SyncSender<SocketResponse>>>
	) -> anyhow::Result<SocketHandler> {
		let sock_res = SocketHandler::get_self_signed_socket(url).await?;

		let (sender, receiver) = sock_res.split();

		SocketHandler::spawn_receiver(receiver, channel_sender, sock_msgs);

		Ok(SocketHandler { sender })
	}

	pub fn spawn_receiver(
		receiver: SplitStream<WebSocketStream<TlsStream<TcpStream>>>,
		channel_sender: mpsc::SyncSender<SocketResponse>,
		sock_msgs: Arc<DashMap<String, mpsc::SyncSender<SocketResponse>>>
	) {
		tokio::spawn(async move {
			let mut rec = receiver;

			while let Some(msg_res) = rec.next().await {
				let res: SocketResponse = match msg_res {
					Ok(msg) => match msg {
						Message::Text(txt) => match serde_json::from_str(&txt) {
							Ok(res) => res,
							_ => continue,
						},
						_ => continue,
					},
					_ => continue,
				};

				let id = res.id.to_owned();

				let should_remove = if let Some(id_send) = sock_msgs.get(&id) {
					let last = res.last;

					match id_send.send(res) {
						// should probably do some error handling?
						_ => ()
					}

					last
				} else {
					match channel_sender.send(res) {
						_ => () // should also handle here as well
					}

					false
				};

				// can't do the remove within the `if let Some(id_send)
				// since that'll deadlock when we carry a shared reference
				// and then try to get a mutable reference to the sock_msgs
				if should_remove {
					sock_msgs.remove(&id);
				}
			}
		});
	}

	pub async fn get_self_signed_socket(
		mut url: url::Url
	) -> anyhow::Result<WebSocketStream<TlsStream<TcpStream>>> {
		let _ = url.set_scheme("wss"); // just in case it was set to http before.

		// need this custom connector so that it connects with
		// SMServer's self-signed cert
		let connector = native_tls::TlsConnector::builder()
			.danger_accept_invalid_certs(true)
			.danger_accept_invalid_hostnames(true)
			.use_sni(false)
			.build()
			.expect("Couldn't build tls connector");

		let tokio_connector = tokio_native_tls::TlsConnector::from(connector);

		let host = url.host().expect("Please supply a socket host")
			.to_string();

		let addr = format!("{}:{}",
			host,
			url.port_or_known_default().unwrap_or(8741)
		);

		// but it was online and it works
		let stream = TcpStream::connect(&addr).await?;

		let tls_stream = tokio_connector.connect(&host, stream).await?;

		Ok(tokio_tungstenite::client_async(url, tls_stream).await?.0)
	}

	// all the functions to send commands are generated by the
	// custom `Command` derive macro, which is run on the enum `APICommand`

	pub async fn send_command(
		&mut self, cmd: APICommand, params: Value
	) -> Result<String, Error> {
		// this returns the `id` that it generates, so that it can
		// later be used to grab the response when it comes back in
		let id = uuid::Uuid::new_v4().to_string();

		let payload = json!({
			"id": id,
			"command": cmd.command_string(),
			"params": params
		});

		self.sender.send(Message::Text(payload.to_string())).await?;

		Ok(id)
	}
}
